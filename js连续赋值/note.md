# JS连续赋值

先看案例
```
let a = { n: 1 }
let b = a
a.x = a = { n: 2 }

console.log(a.x)
console.log(b.x)
```
见demo1
**结果：** undefined, { n: 2 }

**解析：**这里有几个点需要注意
- .符号运算的优先级 > 赋值符号(=)
- 赋值符号具有右结合性（执行的方向是从右往左，先执行 = 右边的表达式，然后把结果赋值给 = 左边的表达式，从这里可以得出 = 属于二元操作符），多个 = 的执行过程，可以类比成"递归"的过程


所有前两行代码执行的时候，a b指向同一块内存{ n: 1 }
第三行代码执行
1. 首先执行a.x，过程中执行一次"左查询"，发现没有x，所有此时a b指向的内存为{ n: 1, x: undefined }
2. 然后执行赋值符号(=)，因为 = 具有右结合性，所以会先执行 a = { n: 2 }（同级 = 从右开始），此时a的指向变为 { n: 2 }，但是a.x仍然是指向 { n: 1, x: undefined } 中的x
3. 执行a.x = a
4. 最后的内存指向如下
   
![](/picture/JS连续赋值1.png) ![](/picture/JS连续赋值2.png)
