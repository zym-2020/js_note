# JS原型

## 构造函数
因为JS中没有类（class）的概念，所以JS使用构造函数来实现继承机制

***

>ES6中的*class*可以看作只是一个语法糖，它的绝大部分的功能，
>
>ES5都可以做到，新的写法只是让原型的写法更加的清晰、
>
>更像面向对象编程的语法而已。（摘自阮一峰的ES6入门）


```
//构造函数

function Persion(name, age) {
    this.name = name;
    this.age = age
}

//实例
const p = new Persion('张三', 18)
```

上诉通过构造函数赋值的属性或者方法，是每个实例的实例属性和实例方法，无法共享公共属性，因此设计出了一个**原型对象**

JS的每个函数在创建的时候，都会生成一个属性**prototype**，这个属性指向一个对象，这个对象就是这个函数的**原型对象**，该**原型对象**中有个属性为**constructor**，指向该函数



# JS原型链

完善Person构造函数
```
//构造函数
function Person(name, age) {
    this.name = name;
    this.age = age;
}

//所以实例共享的公共方法
Person.prototype.say = function (word) {
    console.log(`${this.name}说：${word}`);
}

const p1 = new Preson('张三', 18); // 创建一个Person实例对象
p1.hasOwnProperty('say') // false 说明不是定义在其本身上的
p1.say('hello world'); // 调用公共方法 打印：张三说：hello world
```

实例p1能调用say这个方法，是因为其本身有个属性**__proto__**，这个属性会指向该**实例对象**的**构造函数**的**原型对象**
>__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环
>境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。（摘自阮一峰的ES6入门）


当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的**__proto__**隐式属性，找到它的**构造函数**的**原型对象**，如果还没有找到就会再在其**构造函数**的**prototype**的**__proto__**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为**原型链**。

>如果通过p1实例对象的__proto__属性赋值，则会改变其构造函数的原型对象，从而被所有实例所共享。所以，我们在开发的时候，要注意不要通过实例对象去改变其构造函数的原型对象，这样会对其他通过该构造函数生成的实例对象造成影响。

![](/picture/原型链.png)